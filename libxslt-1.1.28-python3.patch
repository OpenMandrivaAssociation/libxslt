--- libxslt-1.1.28/python/generator.py.0004~	2012-09-04 16:26:23.000000000 +0200
+++ libxslt-1.1.28/python/generator.py	2014-07-05 15:43:02.299358427 +0200
@@ -6,8 +6,17 @@
 functions = {}
 enums = {} # { enumType: { enumConstant: enumValue } }
 
+import os
+import sys
 import string
 
+if __name__ == "__main__":
+    # launched as a script
+    srcPref = os.path.dirname(sys.argv[0])
+else:
+    # imported
+    srcPref = os.path.dirname(__file__)
+
 #######################################################################
 #
 #  That part if purely the API acquisition phase from the
@@ -18,7 +27,6 @@ import os
 import xml.sax
 
 debug = 0
-srcdir = os.getenv("SRCDIR", ".")
 
 def getparser():
     # Attach parser to an unmarshalling object. return both objects.
@@ -39,31 +47,34 @@ class docParser(xml.sax.handler.ContentH
 
     def close(self):
         if debug:
-            print "close"
+            print("close")
 
     def getmethodname(self):
         return self._methodname
 
     def data(self, text):
         if debug:
-            print "data %s" % text
+            print("data %s" % text)
         self._data.append(text)
 
     def start(self, tag, attrs):
         if debug:
-            print "start %s, %s" % (tag, attrs)
+            print("start %s, %s" % (tag, attrs))
         if tag == 'function':
             self._data = []
             self.in_function = 1
             self.function = None
+            self.function_cond = None
             self.function_args = []
             self.function_descr = None
             self.function_return = None
             self.function_file = None
-            if attrs.has_key('name'):
+            if 'name' in attrs.keys():
                 self.function = attrs['name']
-            if attrs.has_key('file'):
+            if 'file' in attrs.keys():
                 self.function_file = attrs['file']
+        elif tag == 'cond':
+            self._data = []
         elif tag == 'info':
             self._data = []
         elif tag == 'arg':
@@ -71,36 +82,34 @@ class docParser(xml.sax.handler.ContentH
                 self.function_arg_name = None
                 self.function_arg_type = None
                 self.function_arg_info = None
-                if attrs.has_key('name'):
+                if 'name' in attrs.keys():
                     self.function_arg_name = attrs['name']
-                if attrs.has_key('type'):
+                if 'type' in attrs.keys():
                     self.function_arg_type = attrs['type']
-                if attrs.has_key('info'):
+                if 'info' in attrs.keys():
                     self.function_arg_info = attrs['info']
         elif tag == 'return':
             if self.in_function == 1:
                 self.function_return_type = None
                 self.function_return_info = None
                 self.function_return_field = None
-                if attrs.has_key('type'):
+                if 'type' in attrs.keys():
                     self.function_return_type = attrs['type']
-                if attrs.has_key('info'):
+                if 'info' in attrs.keys():
                     self.function_return_info = attrs['info']
-                if attrs.has_key('field'):
+                if 'field' in attrs.keys():
                     self.function_return_field = attrs['field']
         elif tag == 'enum':
-            enum(attrs['type'],attrs['name'],attrs['value']) 
-        
-
+            enum(attrs['type'],attrs['name'],attrs['value'])
 
     def end(self, tag):
         if debug:
-            print "end %s" % tag
+            print("end %s" % tag)
         if tag == 'function':
             if self.function != None:
                 function(self.function, self.function_descr,
                          self.function_return, self.function_args,
-                         self.function_file)
+                         self.function_file, self.function_cond)
                 self.in_function = 0
         elif tag == 'arg':
             if self.in_function == 1:
@@ -118,15 +127,21 @@ class docParser(xml.sax.handler.ContentH
                 str = str + c
             if self.in_function == 1:
                 self.function_descr = str
-                
-                
-def function(name, desc, ret, args, file):
-    functions[name] = (desc, ret, args, file)
+        elif tag == 'cond':
+            str = ''
+            for c in self._data:
+                str = str + c
+            if self.in_function == 1:
+                self.function_cond = str
+
+
+def function(name, desc, ret, args, file, cond):
+    functions[name] = (desc, ret, args, file, cond)
 
 def enum(type, name, value):
-    if not enums.has_key(type):
+    if type not in enums:
         enums[type] = {}
-    enums[type][name] = value 
+    enums[type][name] = value
 
 #######################################################################
 #
@@ -142,8 +157,7 @@ skipped_modules = {
     'hash': None,
     'list': None,
     'threads': None,
-    'xpointer': None,
-    'transform': None,
+#    'xpointer': None,
 }
 skipped_types = {
     'int *': "usually a return type",
@@ -165,80 +179,102 @@ skipped_types = {
 #######################################################################
 
 py_types = {
-    'void': (None, None, None, None, None),
-    'int':  ('i', None, "int", "int", "libxml_"),
-    'long':  ('l', None, "long", "long", "libxml_"),
-    'double':  ('d', None, "double", "double", "libxml_"),
-    'unsigned int':  ('i', None, "int", "int", "libxml_"),
-    'xmlChar':  ('c', None, "int", "int", "libxml_"),
-    'unsigned char *':  ('z', None, "charPtr", "char *", "libxml_"),
-    'char *':  ('z', None, "charPtr", "char *", "libxml_"),
-    'const char *':  ('z', None, "charPtrConst", "const char *", "libxml_"),
-    'xmlChar *':  ('z', None, "xmlCharPtr", "xmlChar *", "libxml_"),
-    'const xmlChar *':  ('z', None, "xmlCharPtrConst", "const xmlChar *", "libxml_"),
-    'xmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlDtdPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlDtdPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlDtd *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlDtd *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlAttrPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlAttrPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlAttr *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlAttr *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlEntityPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlEntityPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlEntity *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const xmlEntity *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlElementPtr':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr", "libxml_"),
-    'const xmlElementPtr':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr", "libxml_"),
-    'xmlElement *':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr", "libxml_"),
-    'const xmlElement *':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr", "libxml_"),
-    'xmlAttributePtr':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr", "libxml_"),
-    'const xmlAttributePtr':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr", "libxml_"),
-    'xmlAttribute *':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr", "libxml_"),
-    'const xmlAttribute *':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr", "libxml_"),
-    'xmlNsPtr':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr", "libxml_"),
-    'const xmlNsPtr':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr", "libxml_"),
-    'xmlNs *':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr", "libxml_"),
-    'const xmlNs *':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr", "libxml_"),
-    'xmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'const xmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'xmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'const xmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'htmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'const htmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'htmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'const htmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr", "libxml_"),
-    'htmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const htmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'htmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'const htmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr", "libxml_"),
-    'xmlXPathContextPtr':  ('O', "xmlXPathContext", "xmlXPathContextPtr", "xmlXPathContextPtr", "libxml_"),
-    'xmlXPathParserContextPtr':  ('O', "xmlXPathParserContext", "xmlXPathParserContextPtr", "xmlXPathParserContextPtr", "libxml_"),
-    'xmlParserCtxtPtr': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr", "libxml_"),
-    'xmlParserCtxt *': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr", "libxml_"),
-    'htmlParserCtxtPtr': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr", "libxml_"),
-    'htmlParserCtxt *': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr", "libxml_"),
+    'void': (None, None, None, None),
+    'int':  ('i', None, "int", "int"),
+    'long':  ('l', None, "long", "long"),
+    'double':  ('d', None, "double", "double"),
+    'unsigned int':  ('i', None, "int", "int"),
+    'xmlChar':  ('c', None, "int", "int"),
+    'unsigned char *':  ('z', None, "charPtr", "char *"),
+    'char *':  ('z', None, "charPtr", "char *"),
+    'const char *':  ('z', None, "charPtrConst", "const char *"),
+    'xmlChar *':  ('z', None, "xmlCharPtr", "xmlChar *"),
+    'const xmlChar *':  ('z', None, "xmlCharPtrConst", "const xmlChar *"),
+    'xmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlDtdPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlDtdPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlDtd *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlDtd *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlAttrPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlAttrPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlAttr *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlAttr *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlEntityPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlEntityPtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlEntity *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const xmlEntity *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlElementPtr':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr"),
+    'const xmlElementPtr':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr"),
+    'xmlElement *':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr"),
+    'const xmlElement *':  ('O', "xmlElement", "xmlElementPtr", "xmlElementPtr"),
+    'xmlAttributePtr':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr"),
+    'const xmlAttributePtr':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr"),
+    'xmlAttribute *':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr"),
+    'const xmlAttribute *':  ('O', "xmlAttribute", "xmlAttributePtr", "xmlAttributePtr"),
+    'xmlNsPtr':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr"),
+    'const xmlNsPtr':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr"),
+    'xmlNs *':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr"),
+    'const xmlNs *':  ('O', "xmlNode", "xmlNsPtr", "xmlNsPtr"),
+    'xmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'const xmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'xmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'const xmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'htmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'const htmlDocPtr':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'htmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'const htmlDoc *':  ('O', "xmlNode", "xmlDocPtr", "xmlDocPtr"),
+    'htmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const htmlNodePtr':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'htmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'const htmlNode *':  ('O', "xmlNode", "xmlNodePtr", "xmlNodePtr"),
+    'xmlXPathContextPtr':  ('O', "xmlXPathContext", "xmlXPathContextPtr", "xmlXPathContextPtr"),
+    'xmlXPathContext *':  ('O', "xpathContext", "xmlXPathContextPtr", "xmlXPathContextPtr"),
+    'xmlXPathParserContextPtr':  ('O', "xmlXPathParserContext", "xmlXPathParserContextPtr", "xmlXPathParserContextPtr"),
+    'xmlParserCtxtPtr': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr"),
+    'xmlParserCtxt *': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr"),
+    'htmlParserCtxtPtr': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr"),
+    'htmlParserCtxt *': ('O', "parserCtxt", "xmlParserCtxtPtr", "xmlParserCtxtPtr"),
+    'xmlValidCtxtPtr': ('O', "ValidCtxt", "xmlValidCtxtPtr", "xmlValidCtxtPtr"),
     'xmlCatalogPtr': ('O', "catalog", "xmlCatalogPtr", "xmlCatalogPtr"),
-    'FILE *': ('O', "File", "FILEPtr", "FILE *", "libxml_"),
-    'xsltTransformContextPtr':  ('O', "transformCtxt", "xsltTransformContextPtr", "xsltTransformContextPtr", "libxslt_"),
-    'xsltTransformContext *':  ('O', "transformCtxt", "xsltTransformContextPtr", "xsltTransformContextPtr", "libxslt_"),
-    'xsltStylePreCompPtr':  ('O', "compiledStyle", "xsltStylePreCompPtr", "xsltStylePreCompPtr", "libxslt_"),
-    'xsltStylePreComp *':  ('O', "compiledStyle", "xsltStylePreCompPtr", "xsltStylePreCompPtr", "libxslt_"),
-    'xsltStylesheetPtr':  ('O', "stylesheet", "xsltStylesheetPtr", "xsltStylesheetPtr", "libxslt_"),
-    'xsltStylesheet *':  ('O', "stylesheet", "xsltStylesheetPtr", "xsltStylesheetPtr", "libxslt_"),
-    'xmlXPathContext *':  ('O', "xpathContext", "xmlXPathContextPtr", "xmlXPathContextPtr", "libxslt_"),
+    'FILE *': ('O', "File", "FILEPtr", "FILE *"),
+    'xmlURIPtr': ('O', "URI", "xmlURIPtr", "xmlURIPtr"),
+    'xmlErrorPtr': ('O', "Error", "xmlErrorPtr", "xmlErrorPtr"),
+    'xmlOutputBufferPtr': ('O', "outputBuffer", "xmlOutputBufferPtr", "xmlOutputBufferPtr"),
+    'xmlParserInputBufferPtr': ('O', "inputBuffer", "xmlParserInputBufferPtr", "xmlParserInputBufferPtr"),
+    'xmlRegexpPtr': ('O', "xmlReg", "xmlRegexpPtr", "xmlRegexpPtr"),
+    'xmlTextReaderLocatorPtr': ('O', "xmlTextReaderLocator", "xmlTextReaderLocatorPtr", "xmlTextReaderLocatorPtr"),
+    'xmlTextReaderPtr': ('O', "xmlTextReader", "xmlTextReaderPtr", "xmlTextReaderPtr"),
+    'xmlRelaxNGPtr': ('O', "relaxNgSchema", "xmlRelaxNGPtr", "xmlRelaxNGPtr"),
+    'xmlRelaxNGParserCtxtPtr': ('O', "relaxNgParserCtxt", "xmlRelaxNGParserCtxtPtr", "xmlRelaxNGParserCtxtPtr"),
+    'xmlRelaxNGValidCtxtPtr': ('O', "relaxNgValidCtxt", "xmlRelaxNGValidCtxtPtr", "xmlRelaxNGValidCtxtPtr"),
+    'xmlSchemaPtr': ('O', "Schema", "xmlSchemaPtr", "xmlSchemaPtr"),
+    'xmlSchemaParserCtxtPtr': ('O', "SchemaParserCtxt", "xmlSchemaParserCtxtPtr", "xmlSchemaParserCtxtPtr"),
+    'xmlSchemaValidCtxtPtr': ('O', "SchemaValidCtxt", "xmlSchemaValidCtxtPtr", "xmlSchemaValidCtxtPtr"),
 }
 
 py_return_types = {
-    'xmlXPathObjectPtr':  ('O', "foo", "xmlXPathObjectPtr", "xmlXPathObjectPtr", "libxml_"),
+    'xmlXPathObjectPtr':  ('O', "foo", "xmlXPathObjectPtr", "xmlXPathObjectPtr"),
 }
 
 unknown_types = {}
 
+foreign_encoding_args = (
+    'htmlCreateMemoryParserCtxt',
+    'htmlCtxtReadMemory',
+    'htmlParseChunk',
+    'htmlReadMemory',
+    'xmlCreateMemoryParserCtxt',
+    'xmlCtxtReadMemory',
+    'xmlCtxtResetPush',
+    'xmlParseChunk',
+    'xmlParseMemory',
+    'xmlReadMemory',
+    'xmlRecoverMemory',
+)
+
 #######################################################################
 #
 #  This part writes the C <-> Python stubs libxslt-py.[ch] and
@@ -246,13 +282,66 @@ unknown_types = {}
 #
 #######################################################################
 
+# Class methods which are written by hand in libxml.c but the Python-level
+# code is still automatically generated (so they are not in skip_function()).
+skip_impl = (
+    'xmlSaveFileTo',
+    'xmlSaveFormatFileTo',
+)
+
 def skip_function(name):
     if name[0:12] == "xmlXPathWrap":
         return 1
-    if name == "xsltMatchPattern":
+    if name == "xmlFreeParserCtxt":
+        return 1
+    if name == "xmlCleanupParser":
+        return 1
+    if name == "xmlFreeTextReader":
         return 1
 #    if name[0:11] == "xmlXPathNew":
 #        return 1
+    # the next function is defined in libxml.c
+    if name == "xmlRelaxNGFreeValidCtxt":
+        return 1
+    if name == "xmlFreeValidCtxt":
+        return 1
+    if name == "xmlSchemaFreeValidCtxt":
+        return 1
+
+#
+# Those are skipped because the Const version is used of the bindings
+# instead.
+#
+    if name == "xmlTextReaderBaseUri":
+        return 1
+    if name == "xmlTextReaderLocalName":
+        return 1
+    if name == "xmlTextReaderName":
+        return 1
+    if name == "xmlTextReaderNamespaceUri":
+        return 1
+    if name == "xmlTextReaderPrefix":
+        return 1
+    if name == "xmlTextReaderXmlLang":
+        return 1
+    if name == "xmlTextReaderValue":
+        return 1
+    if name == "xmlOutputBufferClose": # handled by by the superclass
+        return 1
+    if name == "xmlOutputBufferFlush": # handled by by the superclass
+        return 1
+    if name == "xmlErrMemory":
+        return 1
+
+    if name == "xmlValidBuildContentModel":
+        return 1
+    if name == "xmlValidateElementDecl":
+        return 1
+    if name == "xmlValidateAttributeDecl":
+        return 1
+    if name == "xmlPopInputCallbacks":
+        return 1
+
     return 0
 
 def print_function_wrapper(name, output, export, include):
@@ -262,15 +351,18 @@ def print_function_wrapper(name, output,
     global skipped_modules
 
     try:
-        (desc, ret, args, file) = functions[name]
+        (desc, ret, args, file, cond) = functions[name]
     except:
-        print "failed to get function %s infos"
+        print("failed to get function %s infos")
         return
 
-    if skipped_modules.has_key(file):
+    if file in skipped_modules:
         return 0
     if skip_function(name) == 1:
         return 0
+    if name in skip_impl:
+        # Don't delete the function entry in the caller.
+        return 1
 
     c_call = ""
     format=""
@@ -278,13 +370,17 @@ def print_function_wrapper(name, output,
     c_args=""
     c_return=""
     c_convert=""
+    c_release=""
+    num_bufs=0
     for arg in args:
         # This should be correct
         if arg[1][0:6] == "const ":
             arg[1] = arg[1][6:]
         c_args = c_args + "    %s %s;\n" % (arg[1], arg[0])
-        if py_types.has_key(arg[1]):
-            (f, t, n, c, p) = py_types[arg[1]]
+        if arg[1] in py_types:
+            (f, t, n, c) = py_types[arg[1]]
+            if (f == 'z') and (name in foreign_encoding_args) and (num_bufs == 0):
+                f = 's#'
             if f != None:
                 format = format + f
             if t != None:
@@ -295,13 +391,20 @@ def print_function_wrapper(name, output,
                    arg[1], t, arg[0])
             else:
                 format_args = format_args + ", &%s" % (arg[0])
+            if f == 's#':
+                format_args = format_args + ", &py_buffsize%d" % num_bufs
+                c_args = c_args + "    int py_buffsize%d;\n" % num_bufs
+                num_bufs = num_bufs + 1
             if c_call != "":
                 c_call = c_call + ", "
             c_call = c_call + "%s" % (arg[0])
+            if t == "File":
+                c_release = c_release + \
+		            "    PyFile_Release(%s);\n" % (arg[0])
         else:
-            if skipped_types.has_key(arg[1]):
+            if arg[1] in skipped_types:
                 return 0
-            if unknown_types.has_key(arg[1]):
+            if arg[1] in unknown_types:
                 lst = unknown_types[arg[1]]
                 lst.append(name)
             else:
@@ -315,56 +418,67 @@ def print_function_wrapper(name, output,
             if args[1][1] == "char *" or args[1][1] == "xmlChar *":
                 c_call = "\n    if (%s->%s != NULL) xmlFree(%s->%s);\n" % (
                                  args[0][0], args[1][0], args[0][0], args[1][0])
-                c_call = c_call + "    %s->%s = xmlStrdup((const xmlChar *)%s);\n" % (args[0][0],
-                                 args[1][0], args[1][0])
+                c_call = c_call + "    %s->%s = (%s)xmlStrdup((const xmlChar *)%s);\n" % (args[0][0],
+                                 args[1][0], args[1][1], args[1][0])
             else:
                 c_call = "\n    %s->%s = %s;\n" % (args[0][0], args[1][0],
                                                    args[1][0])
         else:
             c_call = "\n    %s(%s);\n" % (name, c_call)
         ret_convert = "    Py_INCREF(Py_None);\n    return(Py_None);\n"
-    elif py_types.has_key(ret[0]):
-        (f, t, n, c, p) = py_types[ret[0]]
-        c_return = "    %s c_retval;\n" % (ret[0])
+    elif ret[0] in py_types:
+        (f, t, n, c) = py_types[ret[0]]
+        c_return = c_return + "    %s c_retval;\n" % (ret[0])
         if file == "python_accessor" and ret[2] != None:
             c_call = "\n    c_retval = %s->%s;\n" % (args[0][0], ret[2])
         else:
             c_call = "\n    c_retval = %s(%s);\n" % (name, c_call)
-        ret_convert = "    py_retval = %s%sWrap((%s) c_retval);\n" % (p,n,c)
+        ret_convert = "    py_retval = libxml_%sWrap((%s) c_retval);\n" % (n,c)
         ret_convert = ret_convert + "    return(py_retval);\n"
-    elif py_return_types.has_key(ret[0]):
-        (f, t, n, c, p) = py_return_types[ret[0]]
-        c_return = "    %s c_retval;\n" % (ret[0])
-        if file == "python_accessor" and ret[2] != None:
-            c_call = "\n    c_retval = %s->%s;\n" % (args[0][0], ret[2])
-        else:
-            c_call = "\n    c_retval = %s(%s);\n" % (name, c_call)
-        ret_convert = "    py_retval = %s%sWrap((%s) c_retval);\n" % (p,n,c)
+    elif ret[0] in py_return_types:
+        (f, t, n, c) = py_return_types[ret[0]]
+        c_return = c_return + "    %s c_retval;\n" % (ret[0])
+        c_call = "\n    c_retval = %s(%s);\n" % (name, c_call)
+        ret_convert = "    py_retval = libxml_%sWrap((%s) c_retval);\n" % (n,c)
         ret_convert = ret_convert + "    return(py_retval);\n"
     else:
-        if skipped_types.has_key(ret[0]):
+        if ret[0] in skipped_types:
             return 0
-        if unknown_types.has_key(ret[0]):
+        if ret[0] in unknown_types:
             lst = unknown_types[ret[0]]
             lst.append(name)
         else:
             unknown_types[ret[0]] = [name]
         return -1
 
+    if cond != None and cond != "":
+        include.write("#if %s\n" % cond)
+        export.write("#if %s\n" % cond)
+        output.write("#if %s\n" % cond)
+
     include.write("PyObject * ")
-    include.write("libxslt_%s(PyObject *self, PyObject *args);\n" % (name))
+    include.write("libxml_%s(PyObject *self, PyObject *args);\n" % (name))
 
-    export.write("    { (char *)\"%s\", libxslt_%s, METH_VARARGS, NULL },\n" % (name, name))
+    export.write("    { (char *)\"%s\", libxml_%s, METH_VARARGS, NULL },\n" %
+                 (name, name))
 
     if file == "python":
         # Those have been manually generated
+        if cond != None and cond != "":
+            include.write("#endif\n")
+            export.write("#endif\n")
+            output.write("#endif\n")
         return 1
-    if file == "python_accessor" and ret[0] != "void" and ret[2] == None:
+    if file == "python_accessor" and ret[0] != "void" and ret[2] is None:
         # Those have been manually generated
+        if cond != None and cond != "":
+            include.write("#endif\n")
+            export.write("#endif\n")
+            output.write("#endif\n")
         return 1
 
     output.write("PyObject *\n")
-    output.write("libxslt_%s(PyObject *self ATTRIBUTE_UNUSED," % (name))
+    output.write("libxml_%s(PyObject *self ATTRIBUTE_UNUSED," % (name))
     output.write(" PyObject *args")
     if format == "":
         output.write(" ATTRIBUTE_UNUSED")
@@ -381,10 +495,16 @@ def print_function_wrapper(name, output,
         output.write("        return(NULL);\n")
     if c_convert != "":
         output.write(c_convert)
-                                                              
+
     output.write(c_call)
+    if c_release != "":
+        output.write(c_release)
     output.write(ret_convert)
     output.write("}\n\n")
+    if cond != None and cond != "":
+        include.write("#endif /* %s */\n" % cond)
+        export.write("#endif /* %s */\n" % cond)
+        output.write("#endif /* %s */\n" % cond)
     return 1
 
 def buildStubs():
@@ -393,38 +513,38 @@ def buildStubs():
     global unknown_types
 
     try:
-        f = open("%s/libxslt-api.xml" % srcdir)
+        f = open(os.path.join(srcPref,"libxslt-api.xml"))
         data = f.read()
         (parser, target)  = getparser()
         parser.feed(data)
         parser.close()
-    except IOError, msg:
+    except IOError as msg:
         try:
-            f = open("%s/../doc/libxslt-api.xml" % srcdir)
+            f = open(os.path.join(srcPref,"..","doc","libxslt-api.xml"))
             data = f.read()
             (parser, target)  = getparser()
             parser.feed(data)
             parser.close()
-        except IOError, msg:
-            print "../doc/libxslt-api.xml", ":", msg
+        except IOError as msg:
+            print(file, ":", msg)
+            sys.exit(1)
 
-    n = len(functions.keys())
-    print "Found %d functions in libxslt-api.xml" % (n)
+    n = len(list(functions.keys()))
+    print("Found %d functions in libxslt-api.xml" % (n))
 
-    py_types['pythonObject'] = ('O', "pythonObject", "pythonObject",
-                                "pythonObject", "libxml_")
+    py_types['pythonObject'] = ('O', "pythonObject", "pythonObject", "pythonObject")
     try:
-        f = open("%s/libxslt-python-api.xml" % srcdir)
+        f = open(os.path.join(srcPref,"libxslt-python-api.xml"))
         data = f.read()
         (parser, target)  = getparser()
         parser.feed(data)
         parser.close()
-    except IOError, msg:
-        print "libxslt-python-api.xml", ":", msg
+    except IOError as msg:
+        print(file, ":", msg)
 
 
-    print "Found %d functions in libxslt-python-api.xml" % (
-          len(functions.keys()) - n)
+    print("Found %d functions in libxslt-python-api.xml" % (
+          len(list(functions.keys())) - n))
     nb_wrap = 0
     failed = 0
     skipped = 0
@@ -435,11 +555,11 @@ def buildStubs():
     export.write("/* Generated */\n\n")
     wrapper = open("libxslt-py.c", "w")
     wrapper.write("/* Generated */\n\n")
-#    wrapper.write("#include \"config.h\"\n")
+    wrapper.write("#include <Python.h>\n")
     wrapper.write("#include <libxslt/xsltconfig.h>\n")
     wrapper.write("#include \"libxslt_wrap.h\"\n")
     wrapper.write("#include \"libxslt-py.h\"\n\n")
-    for function in functions.keys():
+    for function in sorted(functions.keys()):
         ret = print_function_wrapper(function, wrapper, export, include)
         if ret < 0:
             failed = failed + 1
@@ -453,12 +573,12 @@ def buildStubs():
     export.close()
     wrapper.close()
 
-    print "Generated %d wrapper functions, %d failed, %d skipped\n" % (nb_wrap,
-                                                              failed, skipped)
-    print "Missing type converters:"
-    for type in unknown_types.keys():
-        print "%s:%d " % (type, len(unknown_types[type])),
-    print
+    print("Generated %d wrapper functions, %d failed, %d skipped\n" % (nb_wrap,
+                                                              failed, skipped))
+    print("Missing type converters: ")
+    for type in list(unknown_types.keys()):
+        print("%s:%d " % (type, len(unknown_types[type])))
+    print()
 
 #######################################################################
 #
@@ -521,11 +641,16 @@ classes_ancestor = {
 classes_destructors = {
     "xpathContext" : "pass"
 }
+functions_noexcept = {
+}
+reference_keepers = {
+}
 
 function_classes = {}
 ctypes = []
 classes_list = []
 
+function_classes["None"] = []
 
 def nameFixup(name, classe, type, file):
     listname = classe + "List"
@@ -533,55 +658,67 @@ def nameFixup(name, classe, type, file):
     l = len(classe)
     if name[0:l] == listname:
         func = name[l:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:12] == "xmlParserGet" and file == "python_accessor":
         func = name[12:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:12] == "xmlParserSet" and file == "python_accessor":
         func = name[12:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:10] == "xmlNodeGet" and file == "python_accessor":
         func = name[10:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:18] == "xsltXPathParserGet" and file == "python_accessor":
+        func = func[0:1].lower() + func[1:]
+    elif name[0:9] == "xmlURIGet" and file == "python_accessor":
+        func = name[9:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:9] == "xmlURISet" and file == "python_accessor":
+        func = name[6:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:11] == "xmlErrorGet" and file == "python_accessor":
+        func = name[11:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:17] == "xmlXPathParserGet" and file == "python_accessor":
+        func = name[17:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:11] == "xmlXPathGet" and file == "python_accessor":
+        func = name[11:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:11] == "xmlXPathSet" and file == "python_accessor":
+        func = name[8:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:15] == "xmlOutputBuffer" and file != "python":
+        func = name[15:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:20] == "xmlParserInputBuffer" and file != "python":
+        func = name[20:]
+        func = func[0:1].lower() + func[1:]
+    elif name[0:9] == "xmlRegexp" and file == "xmlregexp":
+        func = "regexp" + name[9:]
+    elif name[0:6] == "xmlReg" and file == "xmlregexp":
+        func = "regexp" + name[6:]
+    elif name[0:20] == "xmlTextReaderLocator" and file == "xmlreader":
+        func = name[20:]
+    elif name[0:18] == "xmlTextReaderConst" and file == "xmlreader":
         func = name[18:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:12] == "xsltXPathGet" and file == "python_accessor":
-        func = name[12:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:16] == "xsltTransformGet" and file == "python_accessor":
-        func = name[16:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:16] == "xsltTransformSet" and file == "python_accessor":
+    elif name[0:13] == "xmlTextReader" and file == "xmlreader":
         func = name[13:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:17] == "xsltStylesheetGet" and file == "python_accessor":
-        func = name[17:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:17] == "xsltStylesheetSet" and file == "python_accessor":
-        func = name[14:]
-        func = string.lower(func[0:1]) + func[1:]
+    elif name[0:12] == "xmlReaderNew" and file == "xmlreader":
+        func = name[9:]
+    elif name[0:11] == "xmlACatalog":
+        func = name[11:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:l] == classe:
         func = name[l:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:7] == "libxml_":
         func = name[7:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:8] == "libxslt_":
-        func = name[8:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:6] == "xmlGet":
         func = name[6:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     elif name[0:3] == "xml":
         func = name[3:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:7] == "xsltGet":
-        func = name[7:]
-        func = string.lower(func[0:1]) + func[1:]
-    elif name[0:4] == "xslt":
-        func = name[4:]
-        func = string.lower(func[0:1]) + func[1:]
+        func = func[0:1].lower() + func[1:]
     else:
         func = name
     if func[0:5] == "xPath":
@@ -596,8 +733,11 @@ def nameFixup(name, classe, type, file):
         func = "URI" + func[3:]
     elif func[0:4] == "uTF8":
         func = "UTF8" + func[4:]
+    elif func[0:3] == 'sAX':
+        func = "SAX" + func[3:]
     return func
 
+
 def functionCompare(info1, info2):
     (index1, func1, name1, ret1, args1, file1) = info1
     (index2, func2, name2, ret2, args2, file2) = info2
@@ -616,11 +756,29 @@ def functionCompare(info1, info2):
         return 1
     return 0
 
+def cmp_to_key(mycmp):
+    'Convert a cmp= function into a key= function'
+    class K(object):
+        def __init__(self, obj, *args):
+            self.obj = obj
+        def __lt__(self, other):
+            return mycmp(self.obj, other.obj) < 0
+        def __gt__(self, other):
+            return mycmp(self.obj, other.obj) > 0
+        def __eq__(self, other):
+            return mycmp(self.obj, other.obj) == 0
+        def __le__(self, other):
+            return mycmp(self.obj, other.obj) <= 0
+        def __ge__(self, other):
+            return mycmp(self.obj, other.obj) >= 0
+        def __ne__(self, other):
+            return mycmp(self.obj, other.obj) != 0
+    return K
 def writeDoc(name, args, indent, output):
-     if functions[name][0] == None or functions[name][0] == "":
+     if functions[name][0] is None or functions[name][0] == "":
          return
      val = functions[name][0]
-     val = string.replace(val, "NULL", "None")
+     val = val.replace("NULL", "None")
      output.write(indent)
      output.write('"""')
      while len(val) > 60:
@@ -628,7 +786,7 @@ def writeDoc(name, args, indent, output)
              val = val[1:]
              continue
          str = val[0:60]
-         i = string.rfind(str, " ")
+         i = str.rfind(" ")
          if i < 0:
              i = 60
          str = val[0:i]
@@ -637,7 +795,7 @@ def writeDoc(name, args, indent, output)
          output.write('\n  ')
          output.write(indent)
      output.write(val)
-     output.write('"""\n')
+     output.write(' """\n')
 
 def buildWrappers():
     global ctypes
@@ -646,7 +804,6 @@ def buildWrappers():
     global unknown_types
     global functions
     global function_classes
-    global libxml2_classes_type
     global classes_type
     global classes_list
     global converter_type
@@ -657,15 +814,17 @@ def buildWrappers():
     global primary_classes
     global classes_ancestor
     global classes_destructors
+    global functions_noexcept
 
-    function_classes["None"] = []
     for type in classes_type.keys():
         function_classes[classes_type[type][2]] = []
-        
+
     #
-    # Build the list of C types to look for ordered to start with
-    # primary classes
+    # Build the list of C types to look for ordered to start
+    # with primary classes
     #
+    ctypes = []
+    classes_list = []
     ctypes_processed = {}
     classes_processed = {}
     for classe in primary_classes:
@@ -676,37 +835,44 @@ def buildWrappers():
             if tinfo[2] == classe:
                 ctypes.append(type)
                 ctypes_processed[type] = ()
-    for type in classes_type.keys():
-        if ctypes_processed.has_key(type):
+    for type in sorted(classes_type.keys()):
+        if type in ctypes_processed:
             continue
         tinfo = classes_type[type]
-        if not classes_processed.has_key(tinfo[2]):
+        if tinfo[2] not in classes_processed:
             classes_list.append(tinfo[2])
             classes_processed[tinfo[2]] = ()
-            
+
         ctypes.append(type)
         ctypes_processed[type] = ()
 
     for name in functions.keys():
         found = 0
-        (desc, ret, args, file) = functions[name]
+        (desc, ret, args, file, cond) = functions[name]
         for type in ctypes:
             classe = classes_type[type][2]
 
-            if name[0:4] == "xslt" and len(args) >= 1 and args[0][1] == type:
+            if name[0:3] == "xml" and len(args) >= 1 and args[0][1] == type:
                 found = 1
                 func = nameFixup(name, classe, type, file)
                 info = (0, func, name, ret, args, file)
                 function_classes[classe].append(info)
-            elif name[0:4] == "xslt" and len(args) >= 2 and args[1][1] == type:
+            elif name[0:3] == "xml" and len(args) >= 2 and args[1][1] == type \
+                and file != "python_accessor":
                 found = 1
                 func = nameFixup(name, classe, type, file)
                 info = (1, func, name, ret, args, file)
                 function_classes[classe].append(info)
-            elif name[0:4] == "xslt" and len(args) >= 3 and args[2][1] == type:
+            elif name[0:4] == "html" and len(args) >= 1 and args[0][1] == type:
                 found = 1
                 func = nameFixup(name, classe, type, file)
-                info = (2, func, name, ret, args, file)
+                info = (0, func, name, ret, args, file)
+                function_classes[classe].append(info)
+            elif name[0:4] == "html" and len(args) >= 2 and args[1][1] == type \
+                and file != "python_accessor":
+                found = 1
+                func = nameFixup(name, classe, type, file)
+                info = (1, func, name, ret, args, file)
                 function_classes[classe].append(info)
         if found == 1:
             continue
@@ -719,15 +885,15 @@ def buildWrappers():
         func = nameFixup(name, "None", file, file)
         info = (0, func, name, ret, args, file)
         function_classes['None'].append(info)
-
+   
     classes = open("libxsltclass.py", "w")
     txt = open("libxsltclass.txt", "w")
     txt.write("          Generated Classes for libxslt-python\n\n")
 
     txt.write("#\n# Global functions of the module\n#\n\n")
-    if function_classes.has_key("None"):
+    if "None" in function_classes:
         flist = function_classes["None"]
-        flist.sort(functionCompare)
+        flist = sorted(flist, key=cmp_to_key(functionCompare))
         oldfile = ""
         for info in flist:
             (index, func, name, ret, args, file) = info
@@ -747,43 +913,67 @@ def buildWrappers():
             writeDoc(name, args, '    ', classes)
 
             for arg in args:
-                if classes_type.has_key(arg[1]):
-                    classes.write("    if %s == None: %s__o = None\n" %
+                if arg[1] in classes_type:
+                    classes.write("    if %s is None: %s__o = None\n" %
                                   (arg[0], arg[0]))
                     classes.write("    else: %s__o = %s%s\n" %
                                   (arg[0], arg[0], classes_type[arg[1]][0]))
-                elif libxml2_classes_type.has_key(arg[1]):
-                    classes.write("    if %s == None: %s__o = None\n" %
-                                  (arg[0], arg[0]))
-                    classes.write("    else: %s__o = %s%s\n" %
-                                  (arg[0], arg[0], libxml2_classes_type[arg[1]][0]))
+                if arg[1] in py_types:
+                    (f, t, n, c) = py_types[arg[1]]
+                    if t == "File":
+                        classes.write("    if %s is not None: %s.flush()\n" % (
+                                      arg[0], arg[0]))
+
             if ret[0] != "void":
                 classes.write("    ret = ")
             else:
                 classes.write("    ")
-            classes.write("libxsltmod.%s(" % name)
+            classes.write("libxml2mod.%s(" % name)
             n = 0
             for arg in args:
                 if n != 0:
                     classes.write(", ")
                 classes.write("%s" % arg[0])
-                if classes_type.has_key(arg[1]):
-                    classes.write("__o")
-                if libxml2_classes_type.has_key(arg[1]):
+                if arg[1] in classes_type:
                     classes.write("__o")
                 n = n + 1
             classes.write(")\n")
+
+# This may be needed to reposition the I/O, but likely to cause more harm
+# than good. Those changes in Python3 really break the model.
+#           for arg in args:
+#               if arg[1] in py_types:
+#                   (f, t, n, c) = py_types[arg[1]]
+#                   if t == "File":
+#                       classes.write("    if %s is not None: %s.seek(0,0)\n"%(
+#                                     arg[0], arg[0]))
+
             if ret[0] != "void":
-                if classes_type.has_key(ret[0]):
-                    classes.write("    if ret == None: return None\n")
+                if ret[0] in classes_type:
+                    #
+                    # Raise an exception
+                    #
+                    if name in functions_noexcept:
+                        classes.write("    if ret is None:return None\n")
+                    elif name.find("URI") >= 0:
+                        classes.write(
+                        "    if ret is None:raise uriError('%s() failed')\n"
+                                      % (name))
+                    elif name.find("XPath") >= 0:
+                        classes.write(
+                        "    if ret is None:raise xpathError('%s() failed')\n"
+                                      % (name))
+                    elif name.find("Parse") >= 0:
+                        classes.write(
+                        "    if ret is None:raise parserError('%s() failed')\n"
+                                      % (name))
+                    else:
+                        classes.write(
+                        "    if ret is None:raise treeError('%s() failed')\n"
+                                      % (name))
                     classes.write("    return ")
                     classes.write(classes_type[ret[0]][1] % ("ret"))
                     classes.write("\n")
-                elif libxml2_classes_type.has_key(ret[0]):
-                    classes.write("    if ret == None: return None\n")
-                    classes.write("    return libxml2.")
-                    classes.write(libxml2_classes_type[ret[0]][1] % ("ret"))
-                    classes.write("\n")
                 else:
                     classes.write("    return ret\n")
             classes.write("\n")
@@ -793,41 +983,60 @@ def buildWrappers():
         if classname == "None":
             pass
         else:
-            if classes_ancestor.has_key(classname):
+            if classname in classes_ancestor:
                 txt.write("\n\nClass %s(%s)\n" % (classname,
                           classes_ancestor[classname]))
                 classes.write("class %s(%s):\n" % (classname,
                               classes_ancestor[classname]))
                 classes.write("    def __init__(self, _obj=None):\n")
-                classes.write("        self._o = None\n")
+                if classes_ancestor[classname] == "xmlCore" or \
+                   classes_ancestor[classname] == "xmlNode":
+                    classes.write("        if checkWrapper(_obj) != 0:")
+                    classes.write("            raise TypeError")
+                    classes.write("('%s got a wrong wrapper object type')\n" % \
+                                classname)
+                if classname in reference_keepers:
+                    rlist = reference_keepers[classname]
+                    for ref in rlist:
+                        classes.write("        self.%s = None\n" % ref[1])
+                classes.write("        self._o = _obj\n")
                 classes.write("        %s.__init__(self, _obj=_obj)\n\n" % (
                               classes_ancestor[classname]))
                 if classes_ancestor[classname] == "xmlCore" or \
                    classes_ancestor[classname] == "xmlNode":
                     classes.write("    def __repr__(self):\n")
-                    format = "%s:%%s" % (classname)
-                    classes.write("        return \"%s\" %% (self.name)\n\n" % (
+                    format = "<%s (%%s) object at 0x%%x>" % (classname)
+                    classes.write("        return \"%s\" %% (self.name, int(pos_id (self)))\n\n" % (
                                   format))
             else:
                 txt.write("Class %s()\n" % (classname))
                 classes.write("class %s:\n" % (classname))
                 classes.write("    def __init__(self, _obj=None):\n")
+                if classname in reference_keepers:
+                    list = reference_keepers[classname]
+                    for ref in list:
+                        classes.write("        self.%s = None\n" % ref[1])
                 classes.write("        if _obj != None:self._o = _obj;return\n")
                 classes.write("        self._o = None\n\n")
-            if classes_destructors.has_key(classname):
+            destruct=None
+            if classname in classes_destructors:
                 classes.write("    def __del__(self):\n")
-                if classes_destructors[classname] == "pass":
-                    classes.write("        pass\n")
-                else:
-                    classes.write("        if self._o != None:\n")
-                    classes.write("            libxsltmod.%s(self._o)\n" %
-                                  classes_destructors[classname])
-                    classes.write("        self._o = None\n\n")
+                classes.write("        if self._o != None:\n")
+                classes.write("            libxml2mod.%s(self._o)\n" %
+                              classes_destructors[classname])
+                classes.write("        self._o = None\n\n")
+                destruct=classes_destructors[classname]
             flist = function_classes[classname]
-            flist.sort(functionCompare)
+            flist = sorted(flist, key=cmp_to_key(functionCompare))
             oldfile = ""
             for info in flist:
                 (index, func, name, ret, args, file) = info
+                #
+                # Do not provide as method the destructors for the class
+                # to avoid double free
+                #
+                if name == destruct:
+                    continue
                 if file != oldfile:
                     if file == "python_accessor":
                         classes.write("    # accessors for %s\n" % (classname))
@@ -850,55 +1059,103 @@ def buildWrappers():
                 writeDoc(name, args, '        ', classes)
                 n = 0
                 for arg in args:
-                    if classes_type.has_key(arg[1]):
+                    if arg[1] in classes_type:
                         if n != index:
-                            classes.write("        if %s == None: %s__o = None\n" %
+                            classes.write("        if %s is None: %s__o = None\n" %
                                           (arg[0], arg[0]))
                             classes.write("        else: %s__o = %s%s\n" %
                                           (arg[0], arg[0], classes_type[arg[1]][0]))
-                    elif libxml2_classes_type.has_key(arg[1]):
-                        classes.write("        if %s == None: %s__o = None\n" %
-                                      (arg[0], arg[0]))
-                        classes.write("        else: %s__o = %s%s\n" %
-                                      (arg[0], arg[0],
-                                       libxml2_classes_type[arg[1]][0]))
                     n = n + 1
                 if ret[0] != "void":
                     classes.write("        ret = ")
                 else:
                     classes.write("        ")
-                classes.write("libxsltmod.%s(" % name)
+                classes.write("libxml2mod.%s(" % name)
                 n = 0
                 for arg in args:
                     if n != 0:
                         classes.write(", ")
                     if n != index:
                         classes.write("%s" % arg[0])
-                        if classes_type.has_key(arg[1]):
-                            classes.write("__o")
-                        elif libxml2_classes_type.has_key(arg[1]):
+                        if arg[1] in classes_type:
                             classes.write("__o")
                     else:
                         classes.write("self")
-                        if classes_type.has_key(arg[1]):
+                        if arg[1] in classes_type:
                             classes.write(classes_type[arg[1]][0])
-                        elif libxml2_classes_type.has_key(arg[1]):
-                            classes.write(libxml2_classes_type[arg[1]][0])
                     n = n + 1
                 classes.write(")\n")
                 if ret[0] != "void":
-                    if classes_type.has_key(ret[0]):
-                        classes.write("        if ret == None: return None\n")
-                        classes.write("        return ")
+                    if ret[0] in classes_type:
+                        #
+                        # Raise an exception
+                        #
+                        if name in functions_noexcept:
+                            classes.write(
+                                "        if ret is None:return None\n")
+                        elif name.find("URI") >= 0:
+                            classes.write(
+                    "        if ret is None:raise uriError('%s() failed')\n"
+                                          % (name))
+                        elif name.find("XPath") >= 0:
+                            classes.write(
+                    "        if ret is None:raise xpathError('%s() failed')\n"
+                                          % (name))
+                        elif name.find("Parse") >= 0:
+                            classes.write(
+                    "        if ret is None:raise parserError('%s() failed')\n"
+                                          % (name))
+                        else:
+                            classes.write(
+                    "        if ret is None:raise treeError('%s() failed')\n"
+                                          % (name))
+
+                        #
+                        # generate the returned class wrapper for the object
+                        #
+                        classes.write("        __tmp = ")
                         classes.write(classes_type[ret[0]][1] % ("ret"))
                         classes.write("\n")
-                    elif libxml2_classes_type.has_key(ret[0]):
-                        classes.write("        if ret == None: return None\n")
-                        classes.write("        return libxml2.")
-                        classes.write(libxml2_classes_type[ret[0]][1] % ("ret"))
-                        classes.write("\n")
-                    elif converter_type.has_key(ret[0]):
-                        classes.write("        if ret == None: return None\n")
+
+                        #
+                        # Sometime one need to keep references of the source
+                        # class in the returned class object.
+                        # See reference_keepers for the list
+                        #
+                        tclass = classes_type[ret[0]][2]
+                        if tclass in reference_keepers:
+                            list = reference_keepers[tclass]
+                            for pref in list:
+                                if pref[0] == classname:
+                                    classes.write("        __tmp.%s = self\n" %
+                                                  pref[1])
+                        #
+                        # return the class
+                        #
+                        classes.write("        return __tmp\n")
+                    elif ret[0] in converter_type:
+                        #
+                        # Raise an exception
+                        #
+                        if name in functions_noexcept:
+                            classes.write(
+                                "        if ret is None:return None")
+                        elif name.find("URI") >= 0:
+                            classes.write(
+                    "        if ret is None:raise uriError('%s() failed')\n"
+                                          % (name))
+                        elif name.find("XPath") >= 0:
+                            classes.write(
+                    "        if ret is None:raise xpathError('%s() failed')\n"
+                                          % (name))
+                        elif name.find("Parse") >= 0:
+                            classes.write(
+                    "        if ret is None:raise parserError('%s() failed')\n"
+                                          % (name))
+                        else:
+                            classes.write(
+                    "        if ret is None:raise treeError('%s() failed')\n"
+                                          % (name))
                         classes.write("        return ")
                         classes.write(converter_type[ret[0]] % ("ret"))
                         classes.write("\n")
@@ -912,10 +1169,10 @@ def buildWrappers():
     for type,enum in enums.items():
         classes.write("# %s\n" % type)
         items = enum.items()
-        items.sort(lambda i1,i2: cmp(long(i1[1]),long(i2[1])))
+        items = sorted(items, key=(lambda i: int(i[1])))
         for name,value in items:
             classes.write("%s = %s\n" % (name,value))
-        classes.write("\n"); 
+        classes.write("\n")
 
     txt.close()
     classes.close()
--- libxslt-1.1.28/python/libxml_wrap.h.0004~	2009-05-12 08:29:34.000000000 +0200
+++ libxslt-1.1.28/python/libxml_wrap.h	2014-07-05 15:42:34.137710496 +0200
@@ -14,6 +14,51 @@
 #include <libxml/HTMLtree.h>
 #include <libxml/xinclude.h>
 #include <libxml/xpointer.h>
+#include <libxml/xmlunicode.h>
+#include <libxml/xmlregexp.h>
+#include <libxml/xmlautomata.h>
+#include <libxml/xmlreader.h>
+#ifdef LIBXML_SCHEMAS_ENABLED
+#include <libxml/relaxng.h>
+#include <libxml/xmlschemas.h>
+#endif
+
+/*
+ * for older versions of Python, we don't use PyBytes, but keep PyString
+ * and don't use Capsule but CObjects
+ */
+#if PY_VERSION_HEX < 0x02070000
+#ifndef PyBytes_Check
+#define PyBytes_Check PyString_Check
+#define PyBytes_Size PyString_Size
+#define PyBytes_AsString PyString_AsString
+#define PyBytes_AS_STRING PyString_AS_STRING
+#define PyBytes_GET_SIZE PyString_GET_SIZE
+
+#define PyCapsule_New PyCObject_FromVoidPtrAndDesc
+#define PyCapsule_CheckExact PyCObject_Check
+#define PyCapsule_GetPointer(o, n) PyCObject_GetDesc((o))
+
+#endif
+#endif
+
+/**
+ * ATTRIBUTE_UNUSED:
+ *
+ * Macro used to signal to GCC unused function parameters
+ * Repeated here since the definition is not available when
+ * compiled outside the libxml2 build tree.
+ */
+#ifdef __GNUC__
+#ifdef ATTRIBUTE_UNUSED
+#undef ATTRIBUTE_UNUSED
+#endif
+#ifndef ATTRIBUTE_UNUSED
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+#endif /* ATTRIBUTE_UNUSED */
+#else
+#define ATTRIBUTE_UNUSED
+#endif
 
 #define PyxmlNode_Get(v) (((v) == Py_None) ? NULL : \
 	(((PyxmlNode_Object *)(v))->obj))
@@ -47,6 +92,14 @@ typedef struct {
     xmlParserCtxtPtr obj;
 } PyparserCtxt_Object;
 
+#define PyValidCtxt_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyValidCtxt_Object *)(v))->obj))
+
+typedef struct {
+	PyObject_HEAD
+	xmlValidCtxtPtr obj;
+} PyValidCtxt_Object;
+
 #define Pycatalog_Get(v) (((v) == Py_None) ? NULL : \
         (((Pycatalog_Object *)(v))->obj))
 
@@ -55,8 +108,128 @@ typedef struct {
     xmlCatalogPtr obj;
 } Pycatalog_Object;
 
+#ifdef LIBXML_REGEXP_ENABLED
+#define PyxmlReg_Get(v) (((v) == Py_None) ? NULL : \
+        (((PyxmlReg_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlRegexpPtr obj;
+} PyxmlReg_Object;
+#endif /* LIBXML_REGEXP_ENABLED */
+
+#ifdef LIBXML_READER_ENABLED
+#define PyxmlTextReader_Get(v) (((v) == Py_None) ? NULL : \
+        (((PyxmlTextReader_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlTextReaderPtr obj;
+} PyxmlTextReader_Object;
+
+#define PyxmlTextReaderLocator_Get(v) (((v) == Py_None) ? NULL : \
+        (((PyxmlTextReaderLocator_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlTextReaderLocatorPtr obj;
+} PyxmlTextReaderLocator_Object;
+#endif
+
+#define PyURI_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyURI_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlErrorPtr obj;
+} PyError_Object;
+
+#define PyError_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyError_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlOutputBufferPtr obj;
+} PyoutputBuffer_Object;
+
+#define PyoutputBuffer_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyoutputBuffer_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlParserInputBufferPtr obj;
+} PyinputBuffer_Object;
+
+#define PyinputBuffer_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyinputBuffer_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlURIPtr obj;
+} PyURI_Object;
+
+/* FILE * have their own internal representation */
+#if PY_MAJOR_VERSION >= 3
+FILE *libxml_PyFileGet(PyObject *f);
+void libxml_PyFileRelease(FILE *f);
+#define PyFile_Get(v) (((v) == Py_None) ? NULL : libxml_PyFileGet(v))
+#define PyFile_Release(f) libxml_PyFileRelease(f)
+#else
 #define PyFile_Get(v) (((v) == Py_None) ? NULL : \
 	(PyFile_Check(v) ? (PyFile_AsFile(v)) : stdout))
+#define PyFile_Release(f)
+#endif
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+typedef struct {
+    PyObject_HEAD
+    xmlRelaxNGPtr obj;
+} PyrelaxNgSchema_Object;
+
+#define PyrelaxNgSchema_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyrelaxNgSchema_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlRelaxNGParserCtxtPtr obj;
+} PyrelaxNgParserCtxt_Object;
+
+#define PyrelaxNgParserCtxt_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyrelaxNgParserCtxt_Object *)(v))->obj))
+
+typedef struct {
+    PyObject_HEAD
+    xmlRelaxNGValidCtxtPtr obj;
+} PyrelaxNgValidCtxt_Object;
+
+#define PyrelaxNgValidCtxt_Get(v) (((v) == Py_None) ? NULL : \
+	(((PyrelaxNgValidCtxt_Object *)(v))->obj))
+
+typedef struct {
+	PyObject_HEAD
+	xmlSchemaPtr obj;
+} PySchema_Object;
+
+#define PySchema_Get(v) (((v) == Py_None) ? NULL : \
+	(((PySchema_Object *)(v))->obj))
+
+typedef struct {
+	PyObject_HEAD
+	xmlSchemaParserCtxtPtr obj;
+} PySchemaParserCtxt_Object;
+
+#define PySchemaParserCtxt_Get(v) (((v) == Py_None) ? NULL : \
+	(((PySchemaParserCtxt_Object *)(v))->obj))
+
+typedef struct {
+	PyObject_HEAD
+	xmlSchemaValidCtxtPtr obj;
+} PySchemaValidCtxt_Object;
+
+#define PySchemaValidCtxt_Get(v) (((v) == Py_None) ? NULL : \
+	(((PySchemaValidCtxt_Object *)(v))->obj))
+
+#endif /* LIBXML_SCHEMAS_ENABLED */
 
 PyObject * libxml_intWrap(int val);
 PyObject * libxml_longWrap(long val);
@@ -77,10 +250,30 @@ PyObject * libxml_xmlXPathContextPtrWrap
 PyObject * libxml_xmlParserCtxtPtrWrap(xmlParserCtxtPtr ctxt);
 PyObject * libxml_xmlXPathParserContextPtrWrap(xmlXPathParserContextPtr ctxt);
 PyObject * libxml_xmlXPathObjectPtrWrap(xmlXPathObjectPtr obj);
+PyObject * libxml_xmlValidCtxtPtrWrap(xmlValidCtxtPtr valid);
 PyObject * libxml_xmlCatalogPtrWrap(xmlCatalogPtr obj);
 PyObject * libxml_xmlURIPtrWrap(xmlURIPtr uri);
 PyObject * libxml_xmlOutputBufferPtrWrap(xmlOutputBufferPtr buffer);
 PyObject * libxml_xmlParserInputBufferPtrWrap(xmlParserInputBufferPtr buffer);
+#ifdef LIBXML_REGEXP_ENABLED
 PyObject * libxml_xmlRegexpPtrWrap(xmlRegexpPtr regexp);
+#endif /* LIBXML_REGEXP_ENABLED */
+#ifdef LIBXML_READER_ENABLED
+PyObject * libxml_xmlTextReaderPtrWrap(xmlTextReaderPtr reader);
+PyObject * libxml_xmlTextReaderLocatorPtrWrap(xmlTextReaderLocatorPtr locator);
+#endif
 
 xmlXPathObjectPtr libxml_xmlXPathObjectPtrConvert(PyObject * obj);
+#ifdef LIBXML_SCHEMAS_ENABLED
+PyObject * libxml_xmlRelaxNGPtrWrap(xmlRelaxNGPtr ctxt);
+PyObject * libxml_xmlRelaxNGParserCtxtPtrWrap(xmlRelaxNGParserCtxtPtr ctxt);
+PyObject * libxml_xmlRelaxNGValidCtxtPtrWrap(xmlRelaxNGValidCtxtPtr valid);
+PyObject * libxml_xmlSchemaPtrWrap(xmlSchemaPtr ctxt);
+PyObject * libxml_xmlSchemaParserCtxtPtrWrap(xmlSchemaParserCtxtPtr ctxt);
+PyObject * libxml_xmlSchemaValidCtxtPtrWrap(xmlSchemaValidCtxtPtr valid);
+#endif /* LIBXML_SCHEMAS_ENABLED */
+PyObject * libxml_xmlErrorPtrWrap(xmlErrorPtr error);
+PyObject * libxml_xmlSchemaSetValidErrors(PyObject * self, PyObject * args);
+PyObject * libxml_xmlRegisterInputCallback(PyObject *self, PyObject *args);
+PyObject * libxml_xmlUnregisterInputCallback(PyObject *self, PyObject *args);
+PyObject * libxml_xmlNodeRemoveNsDef(PyObject * self, PyObject * args);
--- libxslt-1.1.28/python/libxslt.c.0004~	2012-09-12 07:58:38.000000000 +0200
+++ libxslt-1.1.28/python/libxslt.c	2014-07-05 15:42:34.137710496 +0200
@@ -55,8 +55,8 @@ libxslt_xsltStylesheetPtrWrap(xsltStyles
 	Py_INCREF(Py_None);
 	return(Py_None);
     }
-    ret = PyCObject_FromVoidPtrAndDesc((void *) style,
-	                               (char *)"xsltStylesheetPtr", NULL);
+    ret = PyCapsule_New((void *) style,
+	                (char *)"xsltStylesheetPtr", NULL);
 
     return(ret);
 }
@@ -72,8 +72,8 @@ libxslt_xsltTransformContextPtrWrap(xslt
 	Py_INCREF(Py_None);
 	return(Py_None);
     }
-    ret = PyCObject_FromVoidPtrAndDesc((void *) ctxt,
-	                               (char *)"xsltTransformContextPtr", NULL);
+    ret = PyCapsule_New((void *) ctxt,
+	                (char *)"xsltTransformContextPtr", NULL);
     return(ret);
 }
 
@@ -88,8 +88,8 @@ libxslt_xsltElemPreCompPtrWrap(xsltElemP
 	Py_INCREF(Py_None);
 	return(Py_None);
     }
-    ret = PyCObject_FromVoidPtrAndDesc((void *) ctxt,
-	                               (char *)"xsltElemPreCompPtr", NULL);
+    ret = PyCapsule_New((void *) ctxt,
+	                (char *)"xsltElemPreCompPtr", NULL);
     return(ret);
 }
 
@@ -107,7 +107,7 @@ libxslt_xsltGetTransformContextHashCode(
     tctxt =  (xsltTransformContextPtr) PytransformCtxt_Get(py_tctxt);
     hash_code = (long) tctxt;
 
-    ret = PyInt_FromLong(hash_code);
+    ret = PyLong_FromLong(hash_code);
     return ret;
 }
 
@@ -144,7 +144,7 @@ libxslt_xsltGetStylesheetHashCode(PyObje
     style =  (xsltStylesheetPtr) Pystylesheet_Get(py_style);
     hash_code = (long) style;
 
-    ret = PyInt_FromLong(hash_code);
+    ret = PyLong_FromLong(hash_code);
     return ret;
 }
 
@@ -598,7 +598,7 @@ libxslt_xsltSetLoaderFunc(PyObject *self
     pythonDocLoaderObject = loader;
     xsltSetLoaderFunc(pythonDocLoaderFuncWrapper);
 
-    py_retval = PyInt_FromLong(0);
+    py_retval = PyLong_FromLong(0);
     return(py_retval);
 }
 
@@ -691,12 +691,12 @@ libxslt_xsltApplyStylesheetUser(PyObject
 		    const char *tmp;
 		    int size;
 
-		    tmp = PyString_AS_STRING(name);
-		    size = PyString_GET_SIZE(name);
+		    tmp = PyBytes_AS_STRING(name);
+		    size = PyBytes_GET_SIZE(name);
 		    params[j * 2] = (char *) xmlCharStrndup(tmp, size);
-		    if (PyString_Check(value)) {
-			tmp = PyString_AS_STRING(value);
-			size = PyString_GET_SIZE(value);
+		    if (PyBytes_Check(value)) {
+			tmp = PyBytes_AS_STRING(value);
+			size = PyBytes_GET_SIZE(value);
 			params[(j * 2) + 1] = (char *)
 			    xmlCharStrndup(tmp, size);
 		    } else {
@@ -767,12 +767,12 @@ libxslt_xsltApplyStylesheet(PyObject *se
 		    const char *tmp;
 		    int size;
 
-		    tmp = PyString_AS_STRING(name);
-		    size = PyString_GET_SIZE(name);
+		    tmp = PyBytes_AS_STRING(name);
+		    size = PyBytes_GET_SIZE(name);
 		    params[j * 2] = (char *) xmlCharStrndup(tmp, size);
-		    if (PyString_Check(value)) {
-			tmp = PyString_AS_STRING(value);
-			size = PyString_GET_SIZE(value);
+		    if (PyBytes_Check(value)) {
+			tmp = PyBytes_AS_STRING(value);
+			size = PyBytes_GET_SIZE(value);
 			params[(j * 2) + 1] = (char *)
 			    xmlCharStrndup(tmp, size);
 		    } else {
@@ -837,11 +837,11 @@ libxslt_xsltSaveResultToString(PyObject
     if(size)
       {
       buffer[size] = '\0';
-      py_retval = PyString_FromString((char *) buffer);
+      py_retval = PyBytes_FromString((char *) buffer);
       xmlFree(buffer);
       }
     else
-      py_retval = PyString_FromString("");
+      py_retval = PyBytes_FromString("");
     return(py_retval);
  FAIL:
     return(0);
@@ -1174,6 +1174,20 @@ static PyMethodDef libxsltMethods[] = {
     { NULL, NULL, 0, NULL }
 };
 
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef moduledef = {
+        PyModuleDef_HEAD_INIT,
+        "libxsltmod",
+        NULL,
+        -1,
+        libxsltMethods,
+        NULL,
+        NULL,
+        NULL,
+        NULL
+};
+#endif
+
 #ifdef MERGED_MODULES
 extern void initlibxml2mod(void);
 #endif
@@ -1188,7 +1202,11 @@ void initlibxsltmod(void) {
 
     if (initialized != 0)
 	return;
+#if PY_MAJOR_VERSION >= 3
+    m = PyModule_Create(&moduledef);
+#else
     m = Py_InitModule((char *)"libxsltmod", libxsltMethods);
+#endif
     initialized = 1;
     /*
      * Specific XSLT initializations
--- libxslt-1.1.28/python/types.c.0004~	2012-09-12 07:58:15.000000000 +0200
+++ libxslt-1.1.28/python/types.c	2014-07-05 15:42:34.137710496 +0200
@@ -1,8 +1,4 @@
 /*
-xmlParserInputPtr xmlNoNetExternalEntityLoader(const char *URL,
-	                                       const char *ID,
-					       xmlParserCtxtPtr ctxt);
-
  * types.c: converter functions between the internal representation
  *          and the Python objects
  *
@@ -13,6 +9,83 @@ xmlParserInputPtr xmlNoNetExternalEntity
 #include "libxml_wrap.h"
 #include <libxml/xpathInternals.h>
 
+#if PY_MAJOR_VERSION >= 3
+#define PY_IMPORT_STRING_SIZE PyUnicode_FromStringAndSize
+#define PY_IMPORT_STRING PyUnicode_FromString
+#define PY_IMPORT_INT PyLong_FromLong
+#else
+#define PY_IMPORT_STRING_SIZE PyString_FromStringAndSize
+#define PY_IMPORT_STRING PyString_FromString
+#define PY_IMPORT_INT PyInt_FromLong
+#endif
+
+#if PY_MAJOR_VERSION >= 3
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+FILE *
+libxml_PyFileGet(PyObject *f) {
+    int fd, flags;
+    FILE *res;
+    const char *mode;
+
+    fd = PyObject_AsFileDescriptor(f);
+    if (!_PyVerify_fd(fd))
+        return(NULL);
+    /*
+     * Get the flags on the fd to understand how it was opened
+     */
+    flags = fcntl(fd, F_GETFL, 0);
+    switch (flags & O_ACCMODE) {
+        case O_RDWR:
+	    if (flags & O_APPEND)
+	        mode = "a+";
+	    else
+	        mode = "rw";
+	    break;
+        case O_RDONLY:
+	    if (flags & O_APPEND)
+	        mode = "r+";
+	    else
+	        mode = "r";
+	    break;
+	case O_WRONLY:
+	    if (flags & O_APPEND)
+	        mode = "a";
+	    else
+	        mode = "w";
+	    break;
+	default:
+	    return(NULL);
+    }
+
+    /*
+     * the FILE struct gets a new fd, so that it can be closed
+     * independently of the file descriptor given. The risk though is
+     * lack of sync. So at the python level sync must be implemented
+     * before and after a conversion took place. No way around it
+     * in the Python3 infrastructure !
+     * The duplicated fd and FILE * will be released in the subsequent
+     * call to libxml_PyFileRelease() which must be genrated accodingly
+     */
+    fd = dup(fd);
+    if (fd == -1)
+        return(NULL);
+    res = fdopen(fd, mode);
+    if (res == NULL) {
+        close(fd);
+	return(NULL);
+    }
+    return(res);
+}
+
+void libxml_PyFileRelease(FILE *f) {
+    if (f != NULL)
+        fclose(f);
+}
+#endif
+
 PyObject *
 libxml_intWrap(int val)
 {
@@ -21,7 +94,7 @@ libxml_intWrap(int val)
 #ifdef DEBUG
     printf("libxml_intWrap: val = %d\n", val);
 #endif
-    ret = PyInt_FromLong((long) val);
+    ret = PY_IMPORT_INT((long) val);
     return (ret);
 }
 
@@ -33,7 +106,7 @@ libxml_longWrap(long val)
 #ifdef DEBUG
     printf("libxml_longWrap: val = %ld\n", val);
 #endif
-    ret = PyInt_FromLong(val);
+    ret = PyLong_FromLong(val);
     return (ret);
 }
 
@@ -61,8 +134,7 @@ libxml_charPtrWrap(char *str)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    /* TODO: look at deallocation */
-    ret = PyString_FromString(str);
+    ret = PY_IMPORT_STRING(str);
     xmlFree(str);
     return (ret);
 }
@@ -79,8 +151,7 @@ libxml_charPtrConstWrap(const char *str)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    /* TODO: look at deallocation */
-    ret = PyString_FromString(str);
+    ret = PY_IMPORT_STRING(str);
     return (ret);
 }
 
@@ -96,8 +167,7 @@ libxml_xmlCharPtrWrap(xmlChar * str)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    /* TODO: look at deallocation */
-    ret = PyString_FromString((char *) str);
+    ret = PY_IMPORT_STRING((char *) str);
     xmlFree(str);
     return (ret);
 }
@@ -114,8 +184,7 @@ libxml_xmlCharPtrConstWrap(const xmlChar
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    /* TODO: look at deallocation */
-    ret = PyString_FromString((char *) str);
+    ret = PY_IMPORT_STRING((char *) str);
     return (ret);
 }
 
@@ -131,8 +200,7 @@ libxml_constcharPtrWrap(const char *str)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    /* TODO: look at deallocation */
-    ret = PyString_FromString(str);
+    ret = PY_IMPORT_STRING(str);
     return (ret);
 }
 
@@ -148,8 +216,7 @@ libxml_constxmlCharPtrWrap(const xmlChar
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    /* TODO: look at deallocation */
-    ret = PyString_FromString((char *) str);
+    ret = PY_IMPORT_STRING((char *) str);
     return (ret);
 }
 
@@ -166,9 +233,7 @@ libxml_xmlDocPtrWrap(xmlDocPtr doc)
         return (Py_None);
     }
     /* TODO: look at deallocation */
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) doc, (char *) "xmlDocPtr",
-                                     NULL);
+    ret = PyCapsule_New((void *) doc, (char *) "xmlDocPtr", NULL);
     return (ret);
 }
 
@@ -184,9 +249,7 @@ libxml_xmlNodePtrWrap(xmlNodePtr node)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) node, (char *) "xmlNodePtr",
-                                     NULL);
+    ret = PyCapsule_New((void *) node, (char *) "xmlNodePtr", NULL);
     return (ret);
 }
 
@@ -202,9 +265,7 @@ libxml_xmlURIPtrWrap(xmlURIPtr uri)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) uri, (char *) "xmlURIPtr",
-                                     NULL);
+    ret = PyCapsule_New((void *) uri, (char *) "xmlURIPtr", NULL);
     return (ret);
 }
 
@@ -220,9 +281,7 @@ libxml_xmlNsPtrWrap(xmlNsPtr ns)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) ns, (char *) "xmlNsPtr",
-                                     NULL);
+    ret = PyCapsule_New((void *) ns, (char *) "xmlNsPtr", NULL);
     return (ret);
 }
 
@@ -238,9 +297,7 @@ libxml_xmlAttrPtrWrap(xmlAttrPtr attr)
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) attr, (char *) "xmlAttrPtr",
-                                     NULL);
+    ret = PyCapsule_New((void *) attr, (char *) "xmlAttrPtr", NULL);
     return (ret);
 }
 
@@ -256,9 +313,7 @@ libxml_xmlAttributePtrWrap(xmlAttributeP
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) attr,
-                                     (char *) "xmlAttributePtr", NULL);
+    ret = PyCapsule_New((void *) attr, (char *) "xmlAttributePtr", NULL);
     return (ret);
 }
 
@@ -274,9 +329,7 @@ libxml_xmlElementPtrWrap(xmlElementPtr e
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) elem,
-                                     (char *) "xmlElementPtr", NULL);
+    ret = PyCapsule_New((void *) elem, (char *) "xmlElementPtr", NULL);
     return (ret);
 }
 
@@ -292,9 +345,7 @@ libxml_xmlXPathContextPtrWrap(xmlXPathCo
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) ctxt,
-                                     (char *) "xmlXPathContextPtr", NULL);
+    ret = PyCapsule_New((void *) ctxt, (char *) "xmlXPathContextPtr", NULL);
     return (ret);
 }
 
@@ -310,9 +361,7 @@ libxml_xmlXPathParserContextPtrWrap(xmlX
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret = PyCObject_FromVoidPtrAndDesc((void *) ctxt,
-                                       (char *) "xmlXPathParserContextPtr",
-                                       NULL);
+    ret = PyCapsule_New((void *)ctxt, (char *)"xmlXPathParserContextPtr", NULL);
     return (ret);
 }
 
@@ -328,28 +377,36 @@ libxml_xmlParserCtxtPtrWrap(xmlParserCtx
         Py_INCREF(Py_None);
         return (Py_None);
     }
-    ret =
-        PyCObject_FromVoidPtrAndDesc((void *) ctxt,
-                                     (char *) "xmlParserCtxtPtr", NULL);
+
+    ret = PyCapsule_New((void *) ctxt, (char *) "xmlParserCtxtPtr", NULL);
     return (ret);
 }
 
 /**
  * libxml_xmlXPathDestructNsNode:
- * cobj: xmlNsPtr namespace node
- * desc: ignored string
+ * cap: xmlNsPtr namespace node capsule object
  *
  * This function is called if and when a namespace node returned in
  * an XPath node set is to be destroyed. That's the only kind of
  * object returned in node set not directly linked to the original
  * xmlDoc document, see xmlXPathNodeSetDupNs.
  */
+#if PY_VERSION_HEX < 0x02070000
+static void
+libxml_xmlXPathDestructNsNode(void *cap, void *desc ATTRIBUTE_UNUSED)
+#else
 static void
-libxml_xmlXPathDestructNsNode(void *cobj, void *desc ATTRIBUTE_UNUSED) {
+libxml_xmlXPathDestructNsNode(PyObject *cap)
+#endif
+{
 #ifdef DEBUG
-    fprintf(stderr, "libxml_xmlXPathDestructNsNode called %p\n", cobj);
+    fprintf(stderr, "libxml_xmlXPathDestructNsNode called %p\n", cap);
+#endif
+#if PY_VERSION_HEX < 0x02070000
+    xmlXPathNodeSetFreeNs((xmlNsPtr) cap);
+#else
+    xmlXPathNodeSetFreeNs((xmlNsPtr) PyCapsule_GetPointer(cap, "xmlNsPtr"));
 #endif
-    xmlXPathNodeSetFreeNs((xmlNsPtr) cobj);
 }
 
 PyObject *
@@ -403,8 +460,7 @@ libxml_xmlXPathObjectPtrWrap(xmlXPathObj
                 for (i = 0; i < obj->nodesetval->nodeNr; i++) {
                     node = obj->nodesetval->nodeTab[i];
                     if (node->type == XML_NAMESPACE_DECL) {
-		        PyObject *ns =
-			    PyCObject_FromVoidPtrAndDesc((void *) node,
+		        PyObject *ns = PyCapsule_New((void *) node,
                                      (char *) "xmlNsPtr",
 				     libxml_xmlXPathDestructNsNode);
 			PyList_SetItem(ret, i, ns);
@@ -417,17 +473,115 @@ libxml_xmlXPathObjectPtrWrap(xmlXPathObj
             }
             break;
         case XPATH_BOOLEAN:
-            ret = PyInt_FromLong((long) obj->boolval);
+            ret = PY_IMPORT_INT((long) obj->boolval);
             break;
         case XPATH_NUMBER:
             ret = PyFloat_FromDouble(obj->floatval);
             break;
         case XPATH_STRING:
-            ret = PyString_FromString((char *) obj->stringval);
+	    ret = PY_IMPORT_STRING((char *) obj->stringval);
             break;
         case XPATH_POINT:
+        {
+            PyObject *node;
+            PyObject *indexIntoNode;
+            PyObject *tuple;
+
+            node = libxml_xmlNodePtrWrap(obj->user);
+            indexIntoNode = PY_IMPORT_INT((long) obj->index);
+
+            tuple = PyTuple_New(2);
+            PyTuple_SetItem(tuple, 0, node);
+            PyTuple_SetItem(tuple, 1, indexIntoNode);
+
+            ret = tuple;
+            break;
+        }
         case XPATH_RANGE:
+        {
+            unsigned short bCollapsedRange;
+
+            bCollapsedRange = ( (obj->user2 == NULL) ||
+		                ((obj->user2 == obj->user) && (obj->index == obj->index2)) );
+            if ( bCollapsedRange ) {
+                PyObject *node;
+                PyObject *indexIntoNode;
+                PyObject *tuple;
+                PyObject *list;
+
+                list = PyList_New(1);
+
+                node = libxml_xmlNodePtrWrap(obj->user);
+                indexIntoNode = PY_IMPORT_INT((long) obj->index);
+
+                tuple = PyTuple_New(2);
+                PyTuple_SetItem(tuple, 0, node);
+                PyTuple_SetItem(tuple, 1, indexIntoNode);
+
+                PyList_SetItem(list, 0, tuple);
+
+                ret = list;
+            } else {
+                PyObject *node;
+                PyObject *indexIntoNode;
+                PyObject *tuple;
+                PyObject *list;
+
+                list = PyList_New(2);
+
+                node = libxml_xmlNodePtrWrap(obj->user);
+                indexIntoNode = PY_IMPORT_INT((long) obj->index);
+
+                tuple = PyTuple_New(2);
+                PyTuple_SetItem(tuple, 0, node);
+                PyTuple_SetItem(tuple, 1, indexIntoNode);
+
+                PyList_SetItem(list, 0, tuple);
+
+                node = libxml_xmlNodePtrWrap(obj->user2);
+                indexIntoNode = PY_IMPORT_INT((long) obj->index2);
+
+                tuple = PyTuple_New(2);
+                PyTuple_SetItem(tuple, 0, node);
+                PyTuple_SetItem(tuple, 1, indexIntoNode);
+
+                PyList_SetItem(list, 1, tuple);
+
+                ret = list;
+            }
+            break;
+        }
         case XPATH_LOCATIONSET:
+        {
+            xmlLocationSetPtr set;
+
+            set = obj->user;
+            if ( set && set->locNr > 0 ) {
+                int i;
+                PyObject *list;
+
+                list = PyList_New(set->locNr);
+
+                for (i=0; i<set->locNr; i++) {
+                    xmlXPathObjectPtr setobj;
+                    PyObject *pyobj;
+
+                    setobj = set->locTab[i]; /*xmlXPathObjectPtr setobj*/
+
+                    pyobj = libxml_xmlXPathObjectPtrWrap(setobj);
+                    /* xmlXPathFreeObject(setobj) is called */
+                    set->locTab[i] = NULL;
+
+                    PyList_SetItem(list, i, pyobj);
+                }
+                set->locNr = 0;
+                ret = list;
+            } else {
+                Py_INCREF(Py_None);
+                ret = Py_None;
+            }
+            break;
+        }
         default:
 #ifdef DEBUG
             printf("Unable to convert XPath object type %d\n", obj->type);
@@ -450,13 +604,15 @@ libxml_xmlXPathObjectPtrConvert(PyObject
     if (obj == NULL) {
         return (NULL);
     }
-    if PyFloat_Check
-        (obj) {
+    if PyFloat_Check (obj) {
         ret = xmlXPathNewFloat((double) PyFloat_AS_DOUBLE(obj));
-    } else if PyInt_Check(obj) {
-
+    } else if PyLong_Check(obj) {
+#ifdef PyLong_AS_LONG
+        ret = xmlXPathNewFloat((double) PyLong_AS_LONG(obj));
+#else
         ret = xmlXPathNewFloat((double) PyInt_AS_LONG(obj));
-
+#endif
+#ifdef PyBool_Check
     } else if PyBool_Check (obj) {
 
         if (obj == Py_True) {
@@ -465,16 +621,38 @@ libxml_xmlXPathObjectPtrConvert(PyObject
         else {
           ret = xmlXPathNewBoolean(0);
         }
+#endif
+    } else if PyBytes_Check (obj) {
+        xmlChar *str;
 
-    } else if PyString_Check
-        (obj) {
+        str = xmlStrndup((const xmlChar *) PyBytes_AS_STRING(obj),
+                         PyBytes_GET_SIZE(obj));
+        ret = xmlXPathWrapString(str);
+#ifdef PyUnicode_Check
+    } else if PyUnicode_Check (obj) {
+#if PY_VERSION_HEX >= 0x03030000
         xmlChar *str;
+	const char *tmp;
+	size_t size;
 
-        str = xmlStrndup((const xmlChar *) PyString_AS_STRING(obj),
-                         PyString_GET_SIZE(obj));
+	/* tmp doesn't need to be deallocated */
+        tmp = PyUnicode_AsUTF8AndSize(obj, &size);
+        str = xmlStrndup(tmp, (int) size);
         ret = xmlXPathWrapString(str);
-    } else if PyList_Check
-        (obj) {
+#else
+        xmlChar *str = NULL;
+        PyObject *b;
+
+	b = PyUnicode_AsUTF8String(obj);
+	if (b != NULL) {
+	    str = xmlStrndup((const xmlChar *) PyBytes_AS_STRING(b),
+			     PyBytes_GET_SIZE(b));
+	    Py_DECREF(b);
+	}
+	ret = xmlXPathWrapString(str);
+#endif
+#endif
+    } else if PyList_Check (obj) {
         int i;
         PyObject *node;
         xmlNodePtr cur;
@@ -488,28 +666,18 @@ libxml_xmlXPathObjectPtrConvert(PyObject
                 continue;
 
             cur = NULL;
-            if (PyCObject_Check(node)) {
+            if (PyCapsule_CheckExact(node)) {
 #ifdef DEBUG
-                printf("Got a CObject\n");
+                printf("Got a Capsule\n");
 #endif
                 cur = PyxmlNode_Get(node);
-            } else if (PyInstance_Check(node)) {
-                PyInstanceObject *inst = (PyInstanceObject *) node;
-                PyObject *name = inst->in_class->cl_name;
-
-                if PyString_Check
-                    (name) {
-                    char *type = PyString_AS_STRING(name);
-                    PyObject *wrapper;
-
-                    if (!strcmp(type, "xmlNode")) {
-                        wrapper =
-                            PyObject_GetAttrString(node, (char *) "_o");
-                        if (wrapper != NULL) {
-                            cur = PyxmlNode_Get(wrapper);
-                        }
-                    }
-                    }
+            } else if ((PyObject_HasAttrString(node, (char *) "_o")) &&
+	               (PyObject_HasAttrString(node, (char *) "get_doc"))) {
+		PyObject *wrapper;
+
+		wrapper = PyObject_GetAttrString(node, (char *) "_o");
+		if (wrapper != NULL)
+		    cur = PyxmlNode_Get(wrapper);
             } else {
 #ifdef DEBUG
                 printf("Unknown object in Python return list\n");
@@ -525,11 +693,30 @@ libxml_xmlXPathObjectPtrConvert(PyObject
         printf("Unable to convert Python Object to XPath");
 #endif
     }
-    Py_DECREF(obj);
     return (ret);
 }
 
 PyObject *
+libxml_xmlValidCtxtPtrWrap(xmlValidCtxtPtr valid)
+{
+	PyObject *ret;
+
+#ifdef DEBUG
+	printf("libxml_xmlValidCtxtPtrWrap: valid = %p\n", valid);
+#endif
+	if (valid == NULL) {
+		Py_INCREF(Py_None);
+		return (Py_None);
+	}
+
+	ret = 
+		PyCapsule_New((void *) valid,
+									 (char *) "xmlValidCtxtPtr", NULL);
+
+	return (ret);
+}
+
+PyObject *
 libxml_xmlCatalogPtrWrap(xmlCatalogPtr catal)
 {
     PyObject *ret;
@@ -542,7 +729,7 @@ libxml_xmlCatalogPtrWrap(xmlCatalogPtr c
         return (Py_None);
     }
     ret =
-        PyCObject_FromVoidPtrAndDesc((void *) catal,
+        PyCapsule_New((void *) catal,
                                      (char *) "xmlCatalogPtr", NULL);
     return (ret);
 }
@@ -560,7 +747,7 @@ libxml_xmlOutputBufferPtrWrap(xmlOutputB
         return (Py_None);
     }
     ret =
-        PyCObject_FromVoidPtrAndDesc((void *) buffer,
+        PyCapsule_New((void *) buffer,
                                      (char *) "xmlOutputBufferPtr", NULL);
     return (ret);
 }
@@ -578,11 +765,12 @@ libxml_xmlParserInputBufferPtrWrap(xmlPa
         return (Py_None);
     }
     ret =
-        PyCObject_FromVoidPtrAndDesc((void *) buffer,
+        PyCapsule_New((void *) buffer,
                                      (char *) "xmlParserInputBufferPtr", NULL);
     return (ret);
 }
 
+#ifdef LIBXML_REGEXP_ENABLED
 PyObject *
 libxml_xmlRegexpPtrWrap(xmlRegexpPtr regexp)
 {
@@ -596,7 +784,174 @@ libxml_xmlRegexpPtrWrap(xmlRegexpPtr reg
         return (Py_None);
     }
     ret =
-        PyCObject_FromVoidPtrAndDesc((void *) regexp,
+        PyCapsule_New((void *) regexp,
                                      (char *) "xmlRegexpPtr", NULL);
     return (ret);
 }
+#endif /* LIBXML_REGEXP_ENABLED */
+
+#ifdef LIBXML_READER_ENABLED
+PyObject *
+libxml_xmlTextReaderPtrWrap(xmlTextReaderPtr reader)
+{
+    PyObject *ret;
+
+#ifdef DEBUG
+    printf("libxml_xmlTextReaderPtrWrap: reader = %p\n", reader);
+#endif
+    if (reader == NULL) {
+        Py_INCREF(Py_None);
+        return (Py_None);
+    }
+    ret =
+        PyCapsule_New((void *) reader,
+                                     (char *) "xmlTextReaderPtr", NULL);
+    return (ret);
+}
+
+PyObject *
+libxml_xmlTextReaderLocatorPtrWrap(xmlTextReaderLocatorPtr locator)
+{
+    PyObject *ret;
+
+#ifdef DEBUG
+    printf("libxml_xmlTextReaderLocatorPtrWrap: locator = %p\n", locator);
+#endif
+    if (locator == NULL) {
+        Py_INCREF(Py_None);
+        return (Py_None);
+    }
+    ret =
+        PyCapsule_New((void *) locator,
+                                     (char *) "xmlTextReaderLocatorPtr", NULL);
+    return (ret);
+}
+#endif /* LIBXML_READER_ENABLED */
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+PyObject *
+libxml_xmlRelaxNGPtrWrap(xmlRelaxNGPtr ctxt)
+{
+    PyObject *ret;
+
+#ifdef DEBUG
+    printf("libxml_xmlRelaxNGPtrWrap: ctxt = %p\n", ctxt);
+#endif
+    if (ctxt == NULL) {
+        Py_INCREF(Py_None);
+        return (Py_None);
+    }
+    ret =
+        PyCapsule_New((void *) ctxt,
+                                     (char *) "xmlRelaxNGPtr", NULL);
+    return (ret);
+}
+
+PyObject *
+libxml_xmlRelaxNGParserCtxtPtrWrap(xmlRelaxNGParserCtxtPtr ctxt)
+{
+    PyObject *ret;
+
+#ifdef DEBUG
+    printf("libxml_xmlRelaxNGParserCtxtPtrWrap: ctxt = %p\n", ctxt);
+#endif
+    if (ctxt == NULL) {
+        Py_INCREF(Py_None);
+        return (Py_None);
+    }
+    ret =
+        PyCapsule_New((void *) ctxt,
+                                     (char *) "xmlRelaxNGParserCtxtPtr", NULL);
+    return (ret);
+}
+PyObject *
+libxml_xmlRelaxNGValidCtxtPtrWrap(xmlRelaxNGValidCtxtPtr valid)
+{
+    PyObject *ret;
+
+#ifdef DEBUG
+    printf("libxml_xmlRelaxNGValidCtxtPtrWrap: valid = %p\n", valid);
+#endif
+    if (valid == NULL) {
+        Py_INCREF(Py_None);
+        return (Py_None);
+    }
+    ret =
+        PyCapsule_New((void *) valid,
+                                     (char *) "xmlRelaxNGValidCtxtPtr", NULL);
+    return (ret);
+}
+
+PyObject *
+libxml_xmlSchemaPtrWrap(xmlSchemaPtr ctxt)
+{
+	PyObject *ret;
+
+#ifdef DEBUG
+	printf("libxml_xmlSchemaPtrWrap: ctxt = %p\n", ctxt);
+#endif
+	if (ctxt == NULL) {
+		Py_INCREF(Py_None);
+		return (Py_None);
+	}
+	ret =
+		PyCapsule_New((void *) ctxt,
+									 (char *) "xmlSchemaPtr", NULL);
+	return (ret);
+}
+
+PyObject *
+libxml_xmlSchemaParserCtxtPtrWrap(xmlSchemaParserCtxtPtr ctxt)
+{
+	PyObject *ret;
+
+#ifdef DEBUG
+	printf("libxml_xmlSchemaParserCtxtPtrWrap: ctxt = %p\n", ctxt);
+#endif
+	if (ctxt == NULL) {
+		Py_INCREF(Py_None);
+		return (Py_None);
+	}
+	ret = 
+		PyCapsule_New((void *) ctxt,
+									 (char *) "xmlSchemaParserCtxtPtr", NULL);
+
+	return (ret);
+}
+
+PyObject *
+libxml_xmlSchemaValidCtxtPtrWrap(xmlSchemaValidCtxtPtr valid)
+{
+	PyObject *ret;
+	
+#ifdef DEBUG
+	printf("libxml_xmlSchemaValidCtxtPtrWrap: valid = %p\n", valid);
+#endif
+	if (valid == NULL) {
+		Py_INCREF(Py_None);
+		return (Py_None);
+	}
+
+	ret = 
+		PyCapsule_New((void *) valid,
+									 (char *) "xmlSchemaValidCtxtPtr", NULL);
+
+	return (ret);
+}
+#endif /* LIBXML_SCHEMAS_ENABLED */
+
+PyObject *
+libxml_xmlErrorPtrWrap(xmlErrorPtr error)
+{
+    PyObject *ret;
+
+#ifdef DEBUG
+    printf("libxml_xmlErrorPtrWrap: error = %p\n", error);
+#endif
+    if (error == NULL) {
+        Py_INCREF(Py_None);
+        return (Py_None);
+    }
+    ret = PyCapsule_New((void *) error, (char *) "xmlErrorPtr", NULL);
+    return (ret);
+}
